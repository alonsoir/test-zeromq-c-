# ml-training-scripts/ddos_detection/GenerateDDOSCPPForest.py
import json
import pickle
import sys
from pathlib import Path
from typing import Dict, List, Any

def load_ddos_model(model_path: str, dataset_path: str):
    """Carga el modelo DDoS y metadata"""
    print(f"ðŸ“‚ Loading DDoS model from: {model_path}")

    with open(model_path, 'rb') as f:
        model = pickle.load(f)

    with open(dataset_path, 'r') as f:
        dataset_info = json.load(f)

    print(f"âœ… DDoS Model loaded: {model.n_estimators} trees, {dataset_info['model_info']['n_features']} features")
    return model, dataset_info

def extract_tree_structure(forest_model, feature_names):
    """Extrae la estructura de todos los Ã¡rboles del RandomForest DDoS"""
    print("ðŸŒ³ Extracting DDoS tree structures...")

    complete_forest = {}
    for i, estimator in enumerate(forest_model.estimators_):
        tree = estimator.tree_

        tree_data = {
            'n_nodes': tree.node_count,
            'children_left': tree.children_left.tolist(),
            'children_right': tree.children_right.tolist(),
            'feature': tree.feature.tolist(),
            'threshold': tree.threshold.tolist(),
            'value': tree.value.tolist()  # Probabilidades por clase [normal, ddos]
        }
        complete_forest[f'tree_{i}'] = tree_data

        if (i + 1) % 10 == 0:
            print(f"  âœ… Processed {i + 1} trees")

    return complete_forest

def generate_ddos_cpp_header(forest_data, dataset_info, output_path: str):
    """Genera el header C++20 para el modelo DDoS con predict()"""
    print(f"ðŸ”§ Generating C++ header: {output_path}")

    model_info = dataset_info['model_info']

    # ABRIR archivo y mantenerlo abierto para toda la funciÃ³n
    f = open(output_path, 'w')

    try:
        # Header
        f.write("// AUTO-GENERATED by GenerateDDOSCPPForest.py\n")
        f.write("// DDoS Detection Model - Normal vs DDoS Traffic\n")
        f.write(f"// Trees: {len(forest_data)}\n")
        f.write(f"// Features: {model_info['n_features']}\n")
        f.write(f"// Classes: {model_info['classes']}\n\n")

        f.write("#pragma once\n\n")
        f.write("#include <cstdint>\n")
        f.write("#include <cstddef>\n\n")

        f.write("namespace ml_defender::ddos {\n\n")

        # TreeNode struct para DDoS
        f.write("struct DDoSTreeNode {\n")
        f.write("    int16_t feature_idx;    // Feature index, -2 if leaf\n")
        f.write("    float threshold;        // Split threshold\n")
        f.write("    int32_t left_child;     // Left child index\n")
        f.write("    int32_t right_child;    // Right child index\n")
        f.write("    float value[2];         // [P(normal), P(ddos)]\n")
        f.write("};\n\n")

        # Generar todos los Ã¡rboles
        total_nodes = 0
        tree_sizes = []

        for tree_id in range(len(forest_data)):
            tree_key = f"tree_{tree_id}"
            tree_data = forest_data[tree_key]
            tree_sizes.append(tree_data['n_nodes'])
            total_nodes += tree_data['n_nodes']

            # Generar cÃ³digo para este Ã¡rbol
            f.write(f"// Tree {tree_id}: {tree_data['n_nodes']} nodes\n")
            f.write(f"inline constexpr DDoSTreeNode {tree_key}[] = {{\n")

            for i in range(tree_data['n_nodes']):
                feature_idx = tree_data['feature'][i]
                threshold = tree_data['threshold'][i]
                left = tree_data['children_left'][i]
                right = tree_data['children_right'][i]

                # Extraer probabilidades (normalizar valores)
                node_values = tree_data['value'][i][0]
                total = sum(node_values)
                prob_normal = node_values[0] / total
                prob_ddos = node_values[1] / total

                f.write(f"    {{{feature_idx}, {threshold:.10f}f, {left}, {right}, ")
                f.write(f"{{{prob_normal:.10f}f, {prob_ddos:.10f}f}}}}")

                if i < tree_data['n_nodes'] - 1:
                    f.write(",")

                # Comentario descriptivo
                if feature_idx == -2:
                    f.write(f"  // Leaf: P(ddos)={prob_ddos:.4f}")
                else:
                    feature_name = model_info['feature_names'][feature_idx] if feature_idx >= 0 else "leaf"
                    f.write(f"  // {feature_name} <= {threshold:.4f}?")

                f.write("\n")

            f.write("};\n\n")

            if (tree_id + 1) % 10 == 0:
                print(f"  âœ… Generated trees 0-{tree_id} ({total_nodes} nodes so far)")

        # Array de punteros a Ã¡rboles
        f.write("// Array of pointers to all trees\n")
        f.write("inline constexpr const DDoSTreeNode* ddos_trees[] = {\n")
        for i in range(len(forest_data)):
            f.write(f"    tree_{i}")
            if i < len(forest_data) - 1:
                f.write(",")
            if (i + 1) % 5 == 0:
                f.write("\n")
        f.write("};\n\n")

        # TamaÃ±os de Ã¡rboles
        f.write("// Number of nodes in each tree\n")
        f.write("inline constexpr size_t ddos_tree_sizes[] = {\n")
        for i in range(len(forest_data)):
            f.write(f"    {tree_sizes[i]}")
            if i < len(forest_data) - 1:
                f.write(",")
            if (i + 1) % 10 == 0:
                f.write("\n")
        f.write("};\n\n")

        # Constantes
        f.write(f"inline constexpr size_t DDOS_NUM_TREES = {len(forest_data)};\n")
        f.write(f"inline constexpr size_t DDOS_NUM_FEATURES = {model_info['n_features']};\n")
        f.write(f"inline constexpr size_t DDOS_TOTAL_NODES = {total_nodes};\n\n")

        # AÃ‘ADIR FUNCIÃ“N PREDICT() - ANTES de cerrar el namespace
        f.write("""/// DDoS Detection Prediction Function
/// @param features Array of 10 feature values in order:
///   [0] syn_ack_ratio
///   [1] packet_symmetry  
///   [2] source_ip_dispersion
///   [3] protocol_anomaly_score
///   [4] packet_size_entropy
///   [5] traffic_amplification_factor
///   [6] flow_completion_rate
///   [7] geographical_concentration
///   [8] traffic_escalation_rate
///   [9] resource_saturation_score
/// @return Probability of DDoS attack (0.0 to 1.0)
inline float predict_ddos(const float features[DDOS_NUM_FEATURES]) {
    float normal_prob = 0.0f;
    float ddos_prob = 0.0f;
    
    for (size_t tree_idx = 0; tree_idx < DDOS_NUM_TREES; ++tree_idx) {
        const DDoSTreeNode* tree = ddos_trees[tree_idx];
        size_t node_idx = 0;
        
        while (true) {
            const auto& node = tree[node_idx];
            
            if (node.feature_idx == -2) { // Leaf node
                normal_prob += node.value[0];
                ddos_prob += node.value[1];
                break;
            }
            
            if (features[node.feature_idx] <= node.threshold) {
                node_idx = node.left_child;
            } else {
                node_idx = node.right_child;
            }
        }
    }
    
    // Return probability of DDoS (class 1)
    return ddos_prob / DDOS_NUM_TREES;
}

} // namespace ml_defender::ddos
""")

    finally:
        # CERRAR archivo explÃ­citamente
        f.close()

    print(f"âœ… Generated DDoS header: {total_nodes} total nodes across {len(forest_data)} trees")
    print(f"ðŸ“Š Average nodes per tree: {total_nodes / len(forest_data):.1f}")

def main():
    if len(sys.argv) != 3:
        print("Usage: python GenerateDDOSCPPForest.py <input_pkl> <output_hpp>")
        print("Example: python GenerateDDOSCPPForest.py ddos_detection_model.pkl ddos_trees_inline.hpp")
        sys.exit(1)

    input_pkl = sys.argv[1]
    input_json = "ddos_detection_dataset.json"
    output_hpp = sys.argv[2]

    # Cargar modelo y datos
    model, dataset_info = load_ddos_model(input_pkl, input_json)

    # Extraer estructura del bosque
    forest_data = extract_tree_structure(model, dataset_info['model_info']['feature_names'])

    # Generar header C++
    generate_ddos_cpp_header(forest_data, dataset_info, output_hpp)

    print(f"\nðŸŽ‰ SUCCESS! Generated: {output_hpp}")
    print(f"ðŸ’¡ Next: Include in your DDoS detector C++ code")

if __name__ == '__main__':
    main()