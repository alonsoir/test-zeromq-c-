# ml-training-scripts/ddos_detection/GenerateDDOSCPPForest.py
import json
import pickle
import sys
from pathlib import Path
from typing import Dict, List, Any
from sklearn.preprocessing import MinMaxScaler
import joblib
import numpy as np

def normalize_thresholds(forest_data, scaler):
    """Normaliza todos los thresholds usando el scaler entrenado"""
    print("üîß Normalizando thresholds a rango [0.0, 1.0]...")

    normalized_forest = {}

    for tree_name, tree_data in forest_data.items():
        normalized_tree = tree_data.copy()
        normalized_thresholds = []

        for feature_idx, threshold in zip(tree_data['feature'], tree_data['threshold']):
            if feature_idx >= 0:  # Solo nodos de decisi√≥n (no hojas)
                # Crear array ficticio para la transformaci√≥n
                dummy_data = np.zeros((1, scaler.n_features_in_))
                dummy_data[0, feature_idx] = threshold

                try:
                    # Transformar a rango normalizado
                    normalized = scaler.transform(dummy_data)
                    normalized_threshold = normalized[0, feature_idx]
                    # Asegurar que est√© en [0,1]
                    normalized_threshold = max(0.0, min(1.0, normalized_threshold))
                    normalized_thresholds.append(normalized_threshold)
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error normalizando threshold: {e}, usando original")
                    normalized_thresholds.append(threshold)
            else:
                # Para nodos hoja, mantener el valor especial
                normalized_thresholds.append(threshold)

        normalized_tree['threshold'] = normalized_thresholds
        normalized_forest[tree_name] = normalized_tree

    return normalized_forest

def load_ddos_model(model_path: str, dataset_path: str):
    """Carga el modelo DDoS, scaler y metadata"""
    print(f"üìÇ Loading DDoS model from: {model_path}")

    with open(model_path, 'rb') as f:
        model = pickle.load(f)

    # ‚úÖ CARGAR SCALER
    scaler_path = 'ddos_scaler.pkl'
    try:
        scaler = joblib.load(scaler_path)
        print(f"‚úÖ DDoS Scaler loaded: {scaler_path}")
    except FileNotFoundError:
        print(f"‚ùå Scaler no encontrado: {scaler_path}")
        scaler = None

    with open(dataset_path, 'r') as f:
        dataset_info = json.load(f)

    print(f"‚úÖ DDoS Model loaded: {model.n_estimators} trees, {dataset_info['model_info']['n_features']} features")
    return model, dataset_info, scaler

def extract_tree_structure(forest_model, feature_names):
    """Extrae la estructura de todos los √°rboles del RandomForest DDoS"""
    print("üå≥ Extracting DDoS tree structures...")

    complete_forest = {}
    for i, estimator in enumerate(forest_model.estimators_):
        tree = estimator.tree_

        tree_data = {
            'n_nodes': tree.node_count,
            'children_left': tree.children_left.tolist(),
            'children_right': tree.children_right.tolist(),
            'feature': tree.feature.tolist(),
            'threshold': tree.threshold.tolist(),
            'value': tree.value.tolist()  # Probabilidades por clase [normal, ddos]
        }
        complete_forest[f'tree_{i}'] = tree_data

        if (i + 1) % 10 == 0:
            print(f"  ‚úÖ Processed {i + 1} trees")

    return complete_forest

def generate_ddos_cpp_header(forest_data, dataset_info, output_path: str):
    """Genera el header C++20 para el modelo DDoS con predict()"""
    print(f"üîß Generating C++ header: {output_path}")

    model_info = dataset_info['model_info']

    # ABRIR archivo y mantenerlo abierto para toda la funci√≥n
    f = open(output_path, 'w')

    try:
        # Header
        f.write("// AUTO-GENERATED by GenerateDDOSCPPForest.py\n")
        f.write("// DDoS Detection Model - Normal vs DDoS Traffic\n")
        f.write(f"// Trees: {len(forest_data)}\n")
        f.write(f"// Features: {model_info['n_features']}\n")
        f.write(f"// Classes: {model_info['classes']}\n\n")

        f.write("#pragma once\n\n")
        f.write("#include <cstdint>\n")
        f.write("#include <cstddef>\n\n")

        f.write("namespace ml_defender::ddos {\n\n")

        # TreeNode struct para DDoS
        f.write("struct DDoSTreeNode {\n")
        f.write("    int16_t feature_idx;    // Feature index, -2 if leaf\n")
        f.write("    float threshold;        // Split threshold\n")
        f.write("    int32_t left_child;     // Left child index\n")
        f.write("    int32_t right_child;    // Right child index\n")
        f.write("    float value[2];         // [P(normal), P(ddos)]\n")
        f.write("};\n\n")

        # Generar todos los √°rboles
        total_nodes = 0
        tree_sizes = []

        for tree_id in range(len(forest_data)):
            tree_key = f"tree_{tree_id}"
            tree_data = forest_data[tree_key]
            tree_sizes.append(tree_data['n_nodes'])
            total_nodes += tree_data['n_nodes']

            # Generar c√≥digo para este √°rbol
            f.write(f"// Tree {tree_id}: {tree_data['n_nodes']} nodes\n")
            f.write(f"inline constexpr DDoSTreeNode {tree_key}[] = {{\n")

            for i in range(tree_data['n_nodes']):
                feature_idx = tree_data['feature'][i]
                threshold = tree_data['threshold'][i]
                left = tree_data['children_left'][i]
                right = tree_data['children_right'][i]

                # Extraer probabilidades (normalizar valores)
                node_values = tree_data['value'][i][0]
                total = sum(node_values)
                prob_normal = node_values[0] / total
                prob_ddos = node_values[1] / total

                f.write(f"    {{{feature_idx}, {threshold:.10f}f, {left}, {right}, ")
                f.write(f"{{{prob_normal:.10f}f, {prob_ddos:.10f}f}}}}")

                if i < tree_data['n_nodes'] - 1:
                    f.write(",")

                # Comentario descriptivo
                if feature_idx == -2:
                    f.write(f"  // Leaf: P(ddos)={prob_ddos:.4f}")
                else:
                    feature_name = model_info['feature_names'][feature_idx] if feature_idx >= 0 else "leaf"
                    f.write(f"  // {feature_name} <= {threshold:.4f}?")

                f.write("\n")

            f.write("};\n\n")

            if (tree_id + 1) % 10 == 0:
                print(f"  ‚úÖ Generated trees 0-{tree_id} ({total_nodes} nodes so far)")

        # Array de punteros a √°rboles
        f.write("// Array of pointers to all trees\n")
        f.write("inline constexpr const DDoSTreeNode* ddos_trees[] = {\n")
        for i in range(len(forest_data)):
            f.write(f"    tree_{i}")
            if i < len(forest_data) - 1:
                f.write(",")
            if (i + 1) % 5 == 0:
                f.write("\n")
        f.write("};\n\n")

        # Tama√±os de √°rboles
        f.write("// Number of nodes in each tree\n")
        f.write("inline constexpr size_t ddos_tree_sizes[] = {\n")
        for i in range(len(forest_data)):
            f.write(f"    {tree_sizes[i]}")
            if i < len(forest_data) - 1:
                f.write(",")
            if (i + 1) % 10 == 0:
                f.write("\n")
        f.write("};\n\n")

        # Constantes
        f.write(f"inline constexpr size_t DDOS_NUM_TREES = {len(forest_data)};\n")
        f.write(f"inline constexpr size_t DDOS_NUM_FEATURES = {model_info['n_features']};\n")
        f.write(f"inline constexpr size_t DDOS_TOTAL_NODES = {total_nodes};\n\n")

        # A√ëADIR FUNCI√ìN PREDICT() - ANTES de cerrar el namespace
        f.write("""/// DDoS Detection Prediction Function
/// @param features Array of 10 feature values in order:
///   [0] syn_ack_ratio
///   [1] packet_symmetry  
///   [2] source_ip_dispersion
///   [3] protocol_anomaly_score
///   [4] packet_size_entropy
///   [5] traffic_amplification_factor
///   [6] flow_completion_rate
///   [7] geographical_concentration
///   [8] traffic_escalation_rate
///   [9] resource_saturation_score
/// @return Probability of DDoS attack (0.0 to 1.0)
inline float predict_ddos(const float features[DDOS_NUM_FEATURES]) {
    float normal_prob = 0.0f;
    float ddos_prob = 0.0f;
    
    for (size_t tree_idx = 0; tree_idx < DDOS_NUM_TREES; ++tree_idx) {
        const DDoSTreeNode* tree = ddos_trees[tree_idx];
        size_t node_idx = 0;
        
        while (true) {
            const auto& node = tree[node_idx];
            
            if (node.feature_idx == -2) { // Leaf node
                normal_prob += node.value[0];
                ddos_prob += node.value[1];
                break;
            }
            
            if (features[node.feature_idx] <= node.threshold) {
                node_idx = node.left_child;
            } else {
                node_idx = node.right_child;
            }
        }
    }
    
    // Return probability of DDoS (class 1)
    return ddos_prob / DDOS_NUM_TREES;
}

} // namespace ml_defender::ddos
""")

    finally:
        # CERRAR archivo expl√≠citamente
        f.close()

    print(f"‚úÖ Generated DDoS header: {total_nodes} total nodes across {len(forest_data)} trees")
    print(f"üìä Average nodes per tree: {total_nodes / len(forest_data):.1f}")

def main():
    if len(sys.argv) != 3:
        print("Usage: python GenerateDDOSCPPForest.py <input_pkl> <output_hpp>")
        print("Example: python GenerateDDOSCPPForest.py ddos_detection_model.pkl ddos_trees_inline.hpp")
        sys.exit(1)

    input_pkl = sys.argv[1]
    input_json = "ddos_detection_dataset.json"
    output_hpp = sys.argv[2]

    # Cargar modelo y datos
    model, dataset_info, scaler = load_ddos_model(
        "ddos_detection_model.pkl",
        "ddos_detection_dataset.json"
    )

    # Extraer estructura del bosque
    feature_names = dataset_info['model_info']['feature_names']
    forest_data = extract_tree_structure(model, feature_names)

    # ‚úÖ NORMALIZAR THRESHOLDS ANTES DE GENERAR HEADER
    if scaler is not None:
        forest_data = normalize_thresholds(forest_data, scaler)
        print("‚úÖ Todos los thresholds normalizados a [0.0, 1.0]")
    else:
        print("‚ö†Ô∏è  No se pudo normalizar thresholds - scaler no disponible")

    # Generar header C++
    generate_ddos_cpp_header(forest_data, dataset_info, "ddos_trees_inline.hpp")

    print(f"\nüéâ SUCCESS! Generated: {output_hpp}")
    print(f"üí° Next: Include in your DDoS detector C++ code")

if __name__ == '__main__':
    main()