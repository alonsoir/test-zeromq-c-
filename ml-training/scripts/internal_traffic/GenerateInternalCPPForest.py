import json
import pickle
import sys
from pathlib import Path
from typing import Dict, List, Any

def load_internal_model(model_path: str, dataset_path: str):
    """Carga el modelo Internal y metadata"""
    print(f"ðŸ“‚ Loading Internal Traffic model from: {model_path}")

    with open(model_path, 'rb') as f:
        model = pickle.load(f)

    with open(dataset_path, 'r') as f:
        dataset_info = json.load(f)

    print(f"âœ… Internal Traffic Model loaded: {model.n_estimators} trees, {dataset_info['model_info']['n_features']} features")
    return model, dataset_info

def extract_tree_structure(forest_model, feature_names):
    """Extrae la estructura de todos los Ã¡rboles del RandomForest Internal"""
    print("ðŸŒ³ Extracting Internal Traffic tree structures...")

    complete_forest = {}
    for i, estimator in enumerate(forest_model.estimators_):
        tree = estimator.tree_

        tree_data = {
            'n_nodes': tree.node_count,
            'children_left': tree.children_left.tolist(),
            'children_right': tree.children_right.tolist(),
            'feature': tree.feature.tolist(),
            'threshold': tree.threshold.tolist(),
            'value': tree.value.tolist()  # Probabilidades por clase [benign, suspicious]
        }
        complete_forest[f'tree_{i}'] = tree_data

        if (i + 1) % 10 == 0:
            print(f"  âœ… Processed {i + 1} trees")

    return complete_forest

def generate_internal_cpp_header(forest_data, dataset_info, output_path: str):
    """Genera el header C++20 para el modelo Internal Traffic"""
    print(f"ðŸ”§ Generating C++ header: {output_path}")

    model_info = dataset_info['model_info']

    # CORRECCIÃ“N: Usar open() y close() explÃ­citamente
    f = open(output_path, 'w')

    try:
        # Header
        f.write("// AUTO-GENERATED by GenerateInternalCPPForest.py\n")
        f.write("// Internal Traffic Classification Model - Benign vs Suspicious\n")
        f.write(f"// Trees: {len(forest_data)}\n")
        f.write(f"// Features: {model_info['n_features']}\n")
        f.write(f"// Classes: {model_info['classes']}\n\n")

        f.write("#pragma once\n\n")
        f.write("#include <cstdint>\n")
        f.write("#include <cstddef>\n\n")

        f.write("namespace ml_defender::internal {\n\n")

        # TreeNode struct para Internal Traffic
        f.write("struct InternalTreeNode {\n")
        f.write("    int16_t feature_idx;    // Feature index, -2 if leaf\n")
        f.write("    float threshold;        // Split threshold\n")
        f.write("    int32_t left_child;     // Left child index\n")
        f.write("    int32_t right_child;    // Right child index\n")
        f.write("    float value[2];         // [P(benign), P(suspicious)]\n")
        f.write("};\n\n")

        # Generar todos los Ã¡rboles
        total_nodes = 0
        tree_sizes = []

        for tree_id in range(len(forest_data)):
            tree_key = f"tree_{tree_id}"
            tree_data = forest_data[tree_key]
            tree_sizes.append(tree_data['n_nodes'])
            total_nodes += tree_data['n_nodes']

            # Generar cÃ³digo para este Ã¡rbol
            f.write(f"// Tree {tree_id}: {tree_data['n_nodes']} nodes\n")
            f.write(f"inline constexpr InternalTreeNode {tree_key}[] = {{\n")

            for i in range(tree_data['n_nodes']):
                feature_idx = tree_data['feature'][i]
                threshold = tree_data['threshold'][i]
                left = tree_data['children_left'][i]
                right = tree_data['children_right'][i]

                # Extraer probabilidades (normalizar valores)
                node_values = tree_data['value'][i][0]
                total = sum(node_values)
                prob_benign = node_values[0] / total
                prob_suspicious = node_values[1] / total

                f.write(f"    {{{feature_idx}, {threshold:.10f}f, {left}, {right}, ")
                f.write(f"{{{prob_benign:.10f}f, {prob_suspicious:.10f}f}}}}")

                if i < tree_data['n_nodes'] - 1:
                    f.write(",")

                # Comentario descriptivo
                if feature_idx == -2:
                    f.write(f"  // Leaf: P(suspicious)={prob_suspicious:.4f}")
                else:
                    feature_name = model_info['feature_names'][feature_idx] if feature_idx >= 0 else "leaf"
                    f.write(f"  // {feature_name} <= {threshold:.4f}?")

                f.write("\n")

            f.write("};\n\n")

            if (tree_id + 1) % 10 == 0:
                print(f"  âœ… Generated trees 0-{tree_id} ({total_nodes} nodes so far)")

        # Array de punteros a Ã¡rboles
        f.write("// Array of pointers to all trees\n")
        f.write("inline constexpr const InternalTreeNode* internal_trees[] = {\n")
        for i in range(len(forest_data)):
            f.write(f"    tree_{i}")
            if i < len(forest_data) - 1:
                f.write(",")
            if (i + 1) % 5 == 0:
                f.write("\n")
        f.write("};\n\n")

        # TamaÃ±os de Ã¡rboles
        f.write("// Number of nodes in each tree\n")
        f.write("inline constexpr size_t internal_tree_sizes[] = {\n")
        for i in range(len(forest_data)):
            f.write(f"    {tree_sizes[i]}")
            if i < len(forest_data) - 1:
                f.write(",")
            if (i + 1) % 10 == 0:
                f.write("\n")
        f.write("};\n\n")

        # Constantes
        f.write(f"inline constexpr size_t INTERNAL_NUM_TREES = {len(forest_data)};\n")
        f.write(f"inline constexpr size_t INTERNAL_NUM_FEATURES = {model_info['n_features']};\n")
        f.write(f"inline constexpr size_t INTERNAL_TOTAL_NODES = {total_nodes};\n\n")

        # CORRECCIÃ“N: AÃ‘ADIR PREDICT FUNCTION DENTRO del archivo abierto
        f.write("""/// Internal Traffic Threat Detection Function
/// @param features Array of feature values
/// @return Probability of SUSPICIOUS internal traffic (0.0 to 1.0)
inline float predict_internal(const float features[INTERNAL_NUM_FEATURES]) {
    float benign_prob = 0.0f;
    float suspicious_prob = 0.0f;
    
    for (size_t tree_idx = 0; tree_idx < INTERNAL_NUM_TREES; ++tree_idx) {
        const InternalTreeNode* tree = internal_trees[tree_idx];
        size_t node_idx = 0;
        
        while (true) {
            const auto& node = tree[node_idx];
            
            if (node.feature_idx == -2) { // Leaf node
                benign_prob += node.value[0];
                suspicious_prob += node.value[1];
                break;
            }
            
            if (features[node.feature_idx] <= node.threshold) {
                node_idx = node.left_child;
            } else {
                node_idx = node.right_child;
            }
        }
    }
    
    // Return probability of SUSPICIOUS traffic (class 1)
    return suspicious_prob / INTERNAL_NUM_TREES;
}

} // namespace ml_defender::internal
""")

    finally:
        # Cerrar archivo explÃ­citamente
        f.close()

    print(f"âœ… Generated Internal Traffic header: {total_nodes} total nodes across {len(forest_data)} trees")
    print(f"ðŸ“Š Average nodes per tree: {total_nodes / len(forest_data):.1f}")

def main():
    if len(sys.argv) != 3:
        print("Usage: python GenerateInternalCPPForest.py <input_pkl> <output_hpp>")
        print("Example: python GenerateInternalCPPForest.py internal_traffic_model.pkl internal_trees_inline.hpp")
        sys.exit(1)

    input_pkl = sys.argv[1]
    input_json = "internal_traffic_dataset.json"
    output_hpp = sys.argv[2]

    # Cargar modelo y datos
    model, dataset_info = load_internal_model(input_pkl, input_json)

    # Extraer estructura del bosque
    forest_data = extract_tree_structure(model, dataset_info['model_info']['feature_names'])

    # Generar header C++
    generate_internal_cpp_header(forest_data, dataset_info, output_hpp)

    print(f"\nðŸŽ‰ SUCCESS! Generated: {output_hpp}")
    print(f"ðŸ’¡ Next: Include in your Internal Traffic detector C++ code")

if __name__ == '__main__':
    main()