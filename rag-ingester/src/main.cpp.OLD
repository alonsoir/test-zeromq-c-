// main.cpp
// RAG Ingester - Main Entry Point
// Day 36: Complete integration with etcd-client for encryption keys

#include <iostream>
#include <csignal>
#include <atomic>
#include <thread>
#include <chrono>

#include <spdlog/spdlog.h>

#include "common/config_parser.hpp"
#include "file_watcher.hpp"
#include "event_loader.hpp"

// TODO Day 37+: Uncomment when integrating etcd-client
// #include <etcd_client/etcd_client.hpp>

namespace {
    std::atomic<bool> running{true};

    void signal_handler(int signal) {
        if (signal == SIGINT || signal == SIGTERM) {
            spdlog::info("Received signal {}, shutting down gracefully...", signal);
            running = false;
        }
    }
}

int main(int argc, char* argv[]) {
    try {
        // ====================================================================
        // 1. Parse Configuration
        // ====================================================================
        std::string config_path = argc > 1 ? argv[1] : "config/rag-ingester.json";

        spdlog::info("RAG Ingester starting...");
        spdlog::info("Loading configuration from: {}", config_path);

        auto config = rag_ingester::load_config(config_path);

        spdlog::info("Configuration loaded:");
        spdlog::info("  Service ID: {}", config.service.id);
        spdlog::info("  Location: {}", config.service.location);
        spdlog::info("  Threading mode: {}", config.ingester.threading.mode);
        spdlog::info("  Input directory: {}", config.ingester.input.directory);
        spdlog::info("  File pattern: {}", config.ingester.input.pattern);
        spdlog::info("  Encrypted: {}", config.ingester.input.encrypted);
        spdlog::info("  Compressed: {}", config.ingester.input.compressed);

        // ====================================================================
        // 2. Register with etcd and get encryption key
        // ====================================================================
        // TODO Day 37+: Replace this hardcoded key with etcd-client integration
        //
        // PRODUCTION CODE (when etcd-client integrated):
        // ```
        // etcd::Client etcd_client(config.service.etcd.endpoints);
        // etcd_client.register_component(config.service.id, config.service.location);
        //
        // // Get ROTATIVE encryption key from etcd
        // std::string encryption_key = etcd_client.get_encryption_key();
        //
        // // Set up key rotation callback (every N minutes)
        // etcd_client.on_key_rotation([&](const std::string& new_key) {
        //     spdlog::info("Encryption key rotated");
        //     // Update EventLoader with new key
        // });
        // ```
        //
        // CURRENT TEST-ONLY CODE:
        std::string encryption_key_path;

        if (config.ingester.input.encrypted) {
            // WARNING: This is TEST-ONLY hardcoded path
            // In production, key comes from etcd-client, NOT from file
            encryption_key_path = "/tmp/test_encryption_key.bin";

            // Create a dummy key for testing (32 bytes of zeros)
            // In production, this comes from etcd
            std::ofstream key_file(encryption_key_path, std::ios::binary);
            std::vector<uint8_t> dummy_key(32, 0x42); // 32 bytes of 'B'
            key_file.write(reinterpret_cast<char*>(dummy_key.data()), 32);
            key_file.close();

            spdlog::warn("⚠️  USING TEST-ONLY ENCRYPTION KEY");
            spdlog::warn("⚠️  In production, key will come from etcd-client");
        } else {
            // No encryption - use dummy path
            encryption_key_path = "/dev/null";
            spdlog::warn("⚠️  Encryption DISABLED - data in plaintext");
        }

        // ====================================================================
        // 3. Initialize EventLoader
        // ====================================================================
        spdlog::info("Initializing EventLoader...");
        rag_ingester::EventLoader loader(encryption_key_path);

        // ====================================================================
        // 4. Initialize FileWatcher
        // ====================================================================
        spdlog::info("Initializing FileWatcher...");
        spdlog::info("  Watching: {}", config.ingester.input.directory);
        spdlog::info("  Pattern: {}", config.ingester.input.pattern);

        rag_ingester::FileWatcher watcher(
            config.ingester.input.directory,
            config.ingester.input.pattern
        );

        // ====================================================================
        // 5. Set up signal handlers
        // ====================================================================
        std::signal(SIGINT, signal_handler);
        std::signal(SIGTERM, signal_handler);

        // ====================================================================
        // 6. Event processing callback
        // ====================================================================
        uint64_t events_processed = 0;
        uint64_t events_failed = 0;

        watcher.on_file_created([&](const std::string& filepath) {
            spdlog::info("New file detected: {}", filepath);

            try {
                auto event = loader.load(filepath);
                events_processed++;

                spdlog::info("Event loaded: id={}, features={}, class={}, confidence={:.4f}",
                    event.event_id,
                    event.features.size(),
                    event.final_class,
                    event.confidence
                );

                // TODO Day 37+: Send to embedders and indexers

                // Delete file if configured
                if (config.ingester.input.delete_after_process) {
                    std::filesystem::remove(filepath);
                    spdlog::debug("Deleted processed file: {}", filepath);
                }

            } catch (const std::exception& e) {
                events_failed++;
                spdlog::error("Failed to process {}: {}", filepath, e.what());

                // If decryption/decompression fails, data might not be encrypted
                // This is EXPECTED if ml-detector hasn't been updated yet
                if (std::string(e.what()).find("decrypt") != std::string::npos ||
                    std::string(e.what()).find("decompress") != std::string::npos) {
                    spdlog::warn("⚠️  File may not be encrypted/compressed yet");
                    spdlog::warn("⚠️  Update ml-detector to encrypt .pb files");
                }
            }
        });

        // ====================================================================
        // 7. Start watching
        // ====================================================================
        watcher.start();
        spdlog::info("✅ RAG Ingester ready and waiting for events");

        // ====================================================================
        // 8. Main loop with statistics
        // ====================================================================
        auto last_stats = std::chrono::steady_clock::now();

        while (running) {
            std::this_thread::sleep_for(std::chrono::seconds(1));

            // Print statistics every 60 seconds
            auto now = std::chrono::steady_clock::now();
            auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - last_stats);

            if (elapsed.count() >= 60) {
                auto stats = loader.get_stats();

                spdlog::info("=== Statistics (last 60s) ===");
                spdlog::info("  Events processed: {}", events_processed);
                spdlog::info("  Events failed: {}", events_failed);
                spdlog::info("  Total loaded: {}", stats.total_loaded);
                spdlog::info("  Total failed: {}", stats.total_failed);
                spdlog::info("  Bytes processed: {}", stats.bytes_processed);
                spdlog::info("  Partial features: {}", stats.partial_feature_count);

                last_stats = now;
            }
        }

        // ====================================================================
        // 9. Graceful shutdown
        // ====================================================================
        spdlog::info("Shutting down...");
        watcher.stop();

        auto final_stats = loader.get_stats();
        spdlog::info("=== Final Statistics ===");
        spdlog::info("  Total events: {}", events_processed);
        spdlog::info("  Failed events: {}", events_failed);
        spdlog::info("  Bytes processed: {}", final_stats.bytes_processed);

        spdlog::info("RAG Ingester stopped gracefully");
        return 0;

    } catch (const std::exception& e) {
        spdlog::error("Fatal error: {}", e.what());
        return 1;
    }
}