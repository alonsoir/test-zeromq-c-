// sniffer/include/feature_extractor.hpp
#pragma once

#include "flow_manager.hpp"
#include <array>
#include <vector>

namespace sniffer {

class FeatureExtractor {
public:
    // ⭐ FASE 2: 43 -> 58 features (70% coverage!)
    static constexpr size_t FEATURE_COUNT = 58;

    // Feature indices for the array
    enum FeatureIndex {
        // === ORIGINALES 23 ===
        DURATION = 0,
        SPKTS,
        DPKTS,
        SBYTES,
        DBYTES,
        SLOAD,
        SMEAN,
        DMEAN,
        FLOW_IAT_MEAN,
        FLOW_IAT_STD,
        FWD_PSH_FLAGS,
        BWD_PSH_FLAGS,
        FWD_URG_FLAGS,
        BWD_URG_FLAGS,
        PACKET_LEN_MEAN,
        PACKET_LEN_STD,
        PACKET_LEN_VAR,
        FIN_FLAG_COUNT,
        SYN_FLAG_COUNT,
        RST_FLAG_COUNT,
        PSH_FLAG_COUNT,
        ACK_FLAG_COUNT,
        URG_FLAG_COUNT,

        // === FASE 1: 20 features ===
        DLOAD,
        RATE,
        SRATE,
        DRATE,
        SPKTS_RATIO,
        SBYTES_RATIO,
        FLOW_IAT_MAX,
        FLOW_IAT_MIN,
        PACKET_LEN_MAX,
        PACKET_LEN_MIN,
        FWD_LEN_MAX,
        FWD_LEN_MIN,
        FWD_LEN_TOT,
        BWD_LEN_MAX,
        BWD_LEN_MIN,
        BWD_LEN_TOT,
        ECE_FLAG_COUNT,
        CWR_FLAG_COUNT,
        FWD_HEADER_LEN_MEAN,
        BWD_HEADER_LEN_MEAN,

        // === FASE 2: 15 NUEVAS FEATURES ===
        // Forward IAT (5)
        FWD_IAT_MEAN,       // 43
        FWD_IAT_STD,        // 44
        FWD_IAT_MAX,        // 45
        FWD_IAT_MIN,        // 46
        FWD_IAT_TOT,        // 47

        // Backward IAT (5)
        BWD_IAT_MEAN,       // 48
        BWD_IAT_STD,        // 49
        BWD_IAT_MAX,        // 50
        BWD_IAT_MIN,        // 51
        BWD_IAT_TOT,        // 52

        // Active/Idle time (4)
        ACTIVE_MEAN,        // 53
        ACTIVE_MAX,         // 54
        IDLE_MEAN,          // 55
        IDLE_MAX,           // 56

        // Additional length stats (2)
        FWD_LEN_STD         // 57
        // BWD_LEN_STD sería 58, pero ya tenemos 58
    };

    FeatureExtractor() = default;

    // Extract all features from a flow
    std::array<double, FEATURE_COUNT> extract_features(const FlowStatistics& flow) const;

    // Get feature name by index
    static const char* get_feature_name(size_t index);

private:
    // === ORIGINAL EXTRACTORS ===
    double extract_duration(const FlowStatistics& flow) const;
    double extract_sload(const FlowStatistics& flow) const;
    double extract_smean(const FlowStatistics& flow) const;
    double extract_dmean(const FlowStatistics& flow) const;
    double extract_flow_iat_mean(const FlowStatistics& flow) const;
    double extract_flow_iat_std(const FlowStatistics& flow) const;
    double extract_packet_len_mean(const FlowStatistics& flow) const;
    double extract_packet_len_std(const FlowStatistics& flow) const;
    double extract_packet_len_var(const FlowStatistics& flow) const;

    // === FASE 1 EXTRACTORS ===
    double extract_dload(const FlowStatistics& flow) const;
    double extract_rate(const FlowStatistics& flow) const;
    double extract_srate(const FlowStatistics& flow) const;
    double extract_drate(const FlowStatistics& flow) const;
    double extract_spkts_ratio(const FlowStatistics& flow) const;
    double extract_sbytes_ratio(const FlowStatistics& flow) const;
    double extract_flow_iat_max(const FlowStatistics& flow) const;
    double extract_flow_iat_min(const FlowStatistics& flow) const;
    double extract_packet_len_max(const FlowStatistics& flow) const;
    double extract_packet_len_min(const FlowStatistics& flow) const;
    double extract_fwd_len_max(const FlowStatistics& flow) const;
    double extract_fwd_len_min(const FlowStatistics& flow) const;
    double extract_fwd_len_tot(const FlowStatistics& flow) const;
    double extract_bwd_len_max(const FlowStatistics& flow) const;
    double extract_bwd_len_min(const FlowStatistics& flow) const;
    double extract_bwd_len_tot(const FlowStatistics& flow) const;
    double extract_fwd_header_len_mean(const FlowStatistics& flow) const;
    double extract_bwd_header_len_mean(const FlowStatistics& flow) const;

    // === FASE 2: NUEVOS EXTRACTORS ===
    // Forward IAT
    double extract_fwd_iat_mean(const FlowStatistics& flow) const;
    double extract_fwd_iat_std(const FlowStatistics& flow) const;
    double extract_fwd_iat_max(const FlowStatistics& flow) const;
    double extract_fwd_iat_min(const FlowStatistics& flow) const;
    double extract_fwd_iat_tot(const FlowStatistics& flow) const;

    // Backward IAT
    double extract_bwd_iat_mean(const FlowStatistics& flow) const;
    double extract_bwd_iat_std(const FlowStatistics& flow) const;
    double extract_bwd_iat_max(const FlowStatistics& flow) const;
    double extract_bwd_iat_min(const FlowStatistics& flow) const;
    double extract_bwd_iat_tot(const FlowStatistics& flow) const;

    // Active/Idle time
    double extract_active_mean(const FlowStatistics& flow) const;
    double extract_active_max(const FlowStatistics& flow) const;
    double extract_idle_mean(const FlowStatistics& flow) const;
    double extract_idle_max(const FlowStatistics& flow) const;

    // Additional length stats
    double extract_fwd_len_std(const FlowStatistics& flow) const;

    // === STATISTICAL HELPERS ===
    double calculate_mean(const std::vector<uint32_t>& values) const;
    double calculate_mean_u16(const std::vector<uint16_t>& values) const;
    double calculate_std(const std::vector<uint32_t>& values) const;
    double calculate_variance(const std::vector<uint32_t>& values) const;
    double calculate_max(const std::vector<uint32_t>& values) const;
    double calculate_min(const std::vector<uint32_t>& values) const;
    double calculate_sum(const std::vector<uint32_t>& values) const;

    // === IAT HELPERS ===
    std::vector<uint64_t> compute_inter_arrival_times(const std::vector<uint64_t>& timestamps) const;
    double calculate_iat_mean(const std::vector<uint64_t>& timestamps) const;
    double calculate_iat_std(const std::vector<uint64_t>& timestamps) const;
    double calculate_iat_max(const std::vector<uint64_t>& timestamps) const;
    double calculate_iat_min(const std::vector<uint64_t>& timestamps) const;
    double calculate_iat_tot(const std::vector<uint64_t>& timestamps) const;

    // === ACTIVE/IDLE HELPERS ===
    struct ActiveIdleTimes {
        std::vector<uint64_t> active_times;   // Periods of continuous activity
        std::vector<uint64_t> idle_times;     // Periods of idleness
    };
    ActiveIdleTimes compute_active_idle_times(const std::vector<uint64_t>& timestamps) const;
};

} // namespace sniffer